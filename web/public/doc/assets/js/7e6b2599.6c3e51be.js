"use strict";(self.webpackChunkbluearc_tiger_docs=self.webpackChunkbluearc_tiger_docs||[]).push([[618],{6068(e,i,n){n.r(i),n.d(i,{assets:()=>t,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"legacy/real-proof-generation-plan","title":"Real Proof Generation Plan (BlueARC)","description":"This is the build plan to replace dev proofs (0x01) with real ZK proofs.","source":"@site/docs/legacy/11-real-proof-generation-plan.md","sourceDirName":"legacy","slug":"/legacy/real-proof-generation-plan","permalink":"/doc/docs/legacy/real-proof-generation-plan","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":11,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"BlueARC Relayer Hosting, Scaling, and Host Fees","permalink":"/doc/docs/legacy/relayer-hosting-scaling-fees"},"next":{"title":"Poseidon P0-P3 Checklist (Execution Tracker)","permalink":"/doc/docs/legacy/poseidon-p0-p3-checklist"}}');var l=n(4848),s=n(8453);const c={},o="Real Proof Generation Plan (BlueARC)",t={},d=[{value:"1) Current State",id:"1-current-state",level:2},{value:"2) Hard Blocker To Resolve First",id:"2-hard-blocker-to-resolve-first",level:2},{value:"Blocker differentiation (why this matters)",id:"blocker-differentiation-why-this-matters",level:3},{value:"Option 1: Poseidon tree (<code>PrivacyPoolV2</code>) + Poseidon circuit (recommended)",id:"option-1-poseidon-tree-privacypoolv2--poseidon-circuit-recommended",level:4},{value:"Option 2: Keep Keccak tree + Keccak circuit (possible)",id:"option-2-keep-keccak-tree--keccak-circuit-possible",level:4},{value:"3) Target Proof Statement",id:"3-target-proof-statement",level:2},{value:"4) Components To Build",id:"4-components-to-build",level:2},{value:"A) Circuits + Prover",id:"a-circuits--prover",level:3},{value:"B) Contract Integration",id:"b-contract-integration",level:3},{value:"Adapter/backend matching rules (must match B)",id:"adapterbackend-matching-rules-must-match-b",level:4},{value:"C) Relayer Integration",id:"c-relayer-integration",level:3},{value:"D) Web Integration",id:"d-web-integration",level:3},{value:"5) Data/Schema Requirements",id:"5-dataschema-requirements",level:2},{value:"Required witness inputs (minimum)",id:"required-witness-inputs-minimum",level:3},{value:"Public signal packing (must match on-chain)",id:"public-signal-packing-must-match-on-chain",level:3},{value:"6) Security/Operations Requirements",id:"6-securityoperations-requirements",level:2},{value:"7) Execution Plan",id:"7-execution-plan",level:2},{value:"Phase P0: Design Lock",id:"phase-p0-design-lock",level:3},{value:"P0.3 Proof encoding (<code>bytes</code> vs split structs)",id:"p03-proof-encoding-bytes-vs-split-structs",level:4},{value:"Noir equivalent (for circom references)",id:"noir-equivalent-for-circom-references",level:3},{value:"Phase P1: Circuit + Verifier",id:"phase-p1-circuit--verifier",level:3},{value:"Phase P2: Relayer + Web",id:"phase-p2-relayer--web",level:3},{value:"Phase P3: Production Hardening",id:"phase-p3-production-hardening",level:3},{value:"Prover hosting options (P2/P3)",id:"prover-hosting-options-p2p3",level:3},{value:"8) Acceptance Criteria",id:"8-acceptance-criteria",level:2}];function a(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(i.header,{children:(0,l.jsx)(i.h1,{id:"real-proof-generation-plan-bluearc",children:"Real Proof Generation Plan (BlueARC)"})}),"\n",(0,l.jsxs)(i.p,{children:["This is the build plan to replace dev proofs (",(0,l.jsx)(i.code,{children:"0x01"}),") with real ZK proofs."]}),"\n",(0,l.jsx)(i.h2,{id:"1-current-state",children:"1) Current State"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"PrivacyPool.withdraw(...)"})," already enforces:","\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"known root"}),"\n",(0,l.jsx)(i.li,{children:"unspent nullifier"}),"\n",(0,l.jsxs)(i.li,{children:["verifier call (",(0,l.jsx)(i.code,{children:"verifier.verifyProof(proof, input)"}),")"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"PqVerifierAdapter"})," is already in place to route to a real verifier backend."]}),"\n",(0,l.jsx)(i.li,{children:"Relayer and web transport are production-leaning (encrypted submit, nonce/replay checks)."}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"2-hard-blocker-to-resolve-first",children:"2) Hard Blocker To Resolve First"}),"\n",(0,l.jsxs)(i.p,{children:["Current tree hash in pool is ",(0,l.jsx)(i.code,{children:"keccak256(left,right)"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"<repo-root>/contracts/contracts/PrivacyPool.sol:248"})}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:"For real SNARK proving, Keccak Merkle constraints are expensive and will make proving heavy."}),"\n",(0,l.jsx)(i.p,{children:"Decision required:"}),"\n",(0,l.jsxs)(i.ol,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Recommended"}),": migrate to Poseidon-based tree in ",(0,l.jsx)(i.code,{children:"PrivacyPoolV2"})," and circuit."]}),"\n",(0,l.jsx)(i.li,{children:"Keep Keccak tree and build heavier circuit (possible, not recommended for operator UX/cost)."}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:"Do not start production prover work until this hash decision is finalized."}),"\n",(0,l.jsx)(i.h3,{id:"blocker-differentiation-why-this-matters",children:"Blocker differentiation (why this matters)"}),"\n",(0,l.jsxs)(i.h4,{id:"option-1-poseidon-tree-privacypoolv2--poseidon-circuit-recommended",children:["Option 1: Poseidon tree (",(0,l.jsx)(i.code,{children:"PrivacyPoolV2"}),") + Poseidon circuit (recommended)"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Fast proving and lower prover memory for Merkle constraints."}),"\n",(0,l.jsx)(i.li,{children:"Better UX for browser/mobile proving and faster remote proving."}),"\n",(0,l.jsx)(i.li,{children:"Cleaner long-term scaling for relay hosts (more proofs per machine)."}),"\n",(0,l.jsxs)(i.li,{children:["Requires a migration to ",(0,l.jsx)(i.code,{children:"PrivacyPoolV2"})," because on-chain tree hash changes."]}),"\n"]}),"\n",(0,l.jsx)(i.h4,{id:"option-2-keep-keccak-tree--keccak-circuit-possible",children:"Option 2: Keep Keccak tree + Keccak circuit (possible)"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"No tree migration in contract logic."}),"\n",(0,l.jsx)(i.li,{children:"Much heavier circuit constraints (slower proving, larger proving infra)."}),"\n",(0,l.jsx)(i.li,{children:"Worse operator economics (higher proving cost, more latency)."}),"\n",(0,l.jsx)(i.li,{children:"More likely to force remote proving even for simple user flows."}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"3-target-proof-statement",children:"3) Target Proof Statement"}),"\n",(0,l.jsx)(i.p,{children:"For one withdrawal, prove:"}),"\n",(0,l.jsxs)(i.ol,{children:["\n",(0,l.jsxs)(i.li,{children:["Witness commitment is in tree for public ",(0,l.jsx)(i.code,{children:"root"}),"."]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"nullifierHash"})," is derived from witness secret and domain tag."]}),"\n",(0,l.jsxs)(i.li,{children:["Public outputs are bound in-circuit:","\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"root"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"nullifierHash"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"recipient"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"relayer"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"fee"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"refund"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"chainId"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:["Public input vector stays length ",(0,l.jsx)(i.code,{children:"7"})," to match current ",(0,l.jsx)(i.code,{children:"withdraw(...)"}),"."]}),"\n",(0,l.jsx)(i.h2,{id:"4-components-to-build",children:"4) Components To Build"}),"\n",(0,l.jsx)(i.h3,{id:"a-circuits--prover",children:"A) Circuits + Prover"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:["New workspace folder: ",(0,l.jsx)(i.code,{children:"circuits/"})]}),"\n",(0,l.jsxs)(i.li,{children:["Files:","\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"circuits/withdraw.circom"})," (or Noir equivalent)"]}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"circuits/lib/merkle.circom"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"circuits/lib/nullifier.circom"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"circuits/inputs/example-withdraw.json"})}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["Build outputs:","\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:["proving key (",(0,l.jsx)(i.code,{children:".zkey"}),"/equivalent)"]}),"\n",(0,l.jsx)(i.li,{children:"verification key JSON"}),"\n",(0,l.jsx)(i.li,{children:"Solidity verifier contract artifact"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"b-contract-integration",children:"B) Contract Integration"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Replace dev external verifier with real verifier contract address."}),"\n",(0,l.jsxs)(i.li,{children:["Keep ",(0,l.jsx)(i.code,{children:"PqVerifierAdapter"})," and set backend mode correctly (",(0,l.jsx)(i.code,{children:"bytes"})," or ",(0,l.jsx)(i.code,{children:"uint"}),")."]}),"\n",(0,l.jsxs)(i.li,{children:["Add integration tests:","\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"valid proof withdraw succeeds"}),"\n",(0,l.jsx)(i.li,{children:"tampered public inputs fail"}),"\n",(0,l.jsx)(i.li,{children:"reused nullifier fails"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:"Current scaffold status:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"PrivacyPoolV2"})," contract exists with pluggable tree hasher."]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"IPoseidonHasher"})," interface exists."]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"PoseidonHasherMock"})," exists for local-only smoke testing."]}),"\n"]}),"\n",(0,l.jsx)(i.h4,{id:"adapterbackend-matching-rules-must-match-b",children:"Adapter/backend matching rules (must match B)"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"PqVerifierAdapter.BackendType.Bytes"}),":","\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:["external verifier must implement:","\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"verify(bytes proof, bytes publicInputs) returns (bool)"})}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["adapter sends ",(0,l.jsx)(i.code,{children:"abi.encode(input)"})," as ",(0,l.jsx)(i.code,{children:"publicInputs"}),"."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"PqVerifierAdapter.BackendType.Uint"}),":","\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:["external verifier must implement:","\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"verifyProof(bytes proof, uint256[] publicInputs) returns (bool)"})}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["adapter sends raw ",(0,l.jsx)(i.code,{children:"uint256[]"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:["If backend type does not match verifier interface, ",(0,l.jsx)(i.code,{children:"withdraw"})," will fail with ",(0,l.jsx)(i.code,{children:"invalid proof"}),"."]}),"\n",(0,l.jsx)(i.h3,{id:"c-relayer-integration",children:"C) Relayer Integration"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Validate proof format version before submit."}),"\n",(0,l.jsxs)(i.li,{children:["Keep size limit (",(0,l.jsx)(i.code,{children:"PROOF_MAX_BYTES"}),") but set realistic bound from real prover output."]}),"\n",(0,l.jsx)(i.li,{children:"Add metrics labels for invalid proof reasons."}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"d-web-integration",children:"D) Web Integration"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:["Replace ",(0,l.jsx)(i.code,{children:"Use Dev Proof (0x01)"})," path with:","\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"load note + Merkle path"}),"\n",(0,l.jsx)(i.li,{children:"generate witness"}),"\n",(0,l.jsx)(i.li,{children:"call prover (local wasm worker or remote proving service)"}),"\n",(0,l.jsx)(i.li,{children:"submit real proof bytes"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"5-dataschema-requirements",children:"5) Data/Schema Requirements"}),"\n",(0,l.jsx)(i.h3,{id:"required-witness-inputs-minimum",children:"Required witness inputs (minimum)"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"noteSecret"})}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"noteRandom"})," (if commitment uses it)"]}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"pathElements[depth]"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"pathIndices[depth]"})}),"\n",(0,l.jsxs)(i.li,{children:["public tuple values (",(0,l.jsx)(i.code,{children:"recipient"}),", ",(0,l.jsx)(i.code,{children:"relayer"}),", ",(0,l.jsx)(i.code,{children:"fee"}),", ",(0,l.jsx)(i.code,{children:"refund"}),", ",(0,l.jsx)(i.code,{children:"chainId"}),", ",(0,l.jsx)(i.code,{children:"root"}),")"]}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"public-signal-packing-must-match-on-chain",children:"Public signal packing (must match on-chain)"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.code,{children:"uint256[7]"}),":"]}),"\n",(0,l.jsxs)(i.ol,{children:["\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"uint256(root)"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"uint256(nullifierHash)"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"uint256(uint160(recipient))"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"uint256(uint160(relayer))"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"fee"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"refund"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"chainId"})}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"6-securityoperations-requirements",children:"6) Security/Operations Requirements"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Domain separation constants for commitment/nullifier."}),"\n",(0,l.jsxs)(i.li,{children:["Versioned proof format (",(0,l.jsx)(i.code,{children:"proofVersion"}),") in app/relayer."]}),"\n",(0,l.jsxs)(i.li,{children:["Proving key integrity:","\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"pin hash in repo docs"}),"\n",(0,l.jsx)(i.li,{children:"verify key hash in CI before deployment"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(i.li,{children:"Ceremony/proving-key provenance documented."}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"7-execution-plan",children:"7) Execution Plan"}),"\n",(0,l.jsx)(i.h3,{id:"phase-p0-design-lock",children:"Phase P0: Design Lock"}),"\n",(0,l.jsxs)(i.ol,{children:["\n",(0,l.jsx)(i.li,{children:"Finalize hash strategy (Poseidon recommended)."}),"\n",(0,l.jsx)(i.li,{children:"Freeze witness/public schema and domain constants."}),"\n",(0,l.jsxs)(i.li,{children:["Define proof encoding (",(0,l.jsx)(i.code,{children:"bytes"})," vs split structs)."]}),"\n"]}),"\n",(0,l.jsxs)(i.h4,{id:"p03-proof-encoding-bytes-vs-split-structs",children:["P0.3 Proof encoding (",(0,l.jsx)(i.code,{children:"bytes"})," vs split structs)"]}),"\n",(0,l.jsx)(i.p,{children:"Why differ:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"bytes"})," encoding:","\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"flexible and verifier-agnostic (Groth16/Plonk/STARK wrappers can pack however they need)"}),"\n",(0,l.jsx)(i.li,{children:"simpler adapter compatibility and upgrade path"}),"\n",(0,l.jsx)(i.li,{children:"easier to transport in relayer/web APIs"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["split structs (",(0,l.jsx)(i.code,{children:"a,b,c"}),"/fixed arrays):","\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"stricter ABI shape, easier static checks"}),"\n",(0,l.jsx)(i.li,{children:"usually tied to one proving system/export format"}),"\n",(0,l.jsx)(i.li,{children:"harder to swap proof system later without contract ABI changes"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:"Recommendation for BlueARC:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:["Keep contract surface as ",(0,l.jsx)(i.code,{children:"bytes proof"})," (current shape)."]}),"\n",(0,l.jsxs)(i.li,{children:["Define canonical ",(0,l.jsx)(i.code,{children:"proofVersion"})," and serialization spec in relayer/web."]}),"\n",(0,l.jsx)(i.li,{children:"Use adapter backend mode to bridge to concrete verifier ABI."}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"noir-equivalent-for-circom-references",children:"Noir equivalent (for circom references)"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:["Circom ",(0,l.jsx)(i.code,{children:"template"}),"/signals ~= Noir ",(0,l.jsx)(i.code,{children:"circuit"})," with typed inputs."]}),"\n",(0,l.jsxs)(i.li,{children:["Circom witness generation ~= Noir ",(0,l.jsx)(i.code,{children:"Prover.toml"}),"/input map + backend witness gen."]}),"\n",(0,l.jsx)(i.li,{children:"Circom Groth16 verifier export ~= Noir backend-specific verifier export (e.g., Barretenberg artifacts)."}),"\n",(0,l.jsxs)(i.li,{children:["Public inputs still must map to the same ",(0,l.jsx)(i.code,{children:"uint256[7]"})," tuple consumed by ",(0,l.jsx)(i.code,{children:"withdraw(...)"}),"."]}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"phase-p1-circuit--verifier",children:"Phase P1: Circuit + Verifier"}),"\n",(0,l.jsxs)(i.ol,{children:["\n",(0,l.jsx)(i.li,{children:"Implement circuit."}),"\n",(0,l.jsx)(i.li,{children:"Generate verifier contract + keys."}),"\n",(0,l.jsx)(i.li,{children:"Add contract tests using real proof fixtures."}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"phase-p2-relayer--web",children:"Phase P2: Relayer + Web"}),"\n",(0,l.jsxs)(i.ol,{children:["\n",(0,l.jsx)(i.li,{children:"Relayer proof version checks and structured errors."}),"\n",(0,l.jsx)(i.li,{children:"Web proof generation flow and progress UX."}),"\n",(0,l.jsx)(i.li,{children:"Remove dev-proof button for production builds."}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"phase-p3-production-hardening",children:"Phase P3: Production Hardening"}),"\n",(0,l.jsxs)(i.ol,{children:["\n",(0,l.jsx)(i.li,{children:"Benchmark proving latency + memory."}),"\n",(0,l.jsx)(i.li,{children:"Add failover strategy for proving service."}),"\n",(0,l.jsx)(i.li,{children:"External audit for circuit constraints and verifier wiring."}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"prover-hosting-options-p2p3",children:"Prover hosting options (P2/P3)"}),"\n",(0,l.jsxs)(i.ol,{children:["\n",(0,l.jsxs)(i.li,{children:["Local WASM worker (in browser/app):","\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"best privacy (no witness leaves client)"}),"\n",(0,l.jsx)(i.li,{children:"constrained by device CPU/RAM and longer proving time"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["Remote proving service:","\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"low-latency UX with stronger hardware"}),"\n",(0,l.jsx)(i.li,{children:"witness leaves client; requires strict transport, auth, and retention policy"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["Hybrid mode:","\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"local proving default"}),"\n",(0,l.jsx)(i.li,{children:"remote fallback when device capability is insufficient"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:"Suggested production posture:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Start with hybrid."}),"\n",(0,l.jsx)(i.li,{children:"Gate remote prover by policy + explicit user consent."}),"\n",(0,l.jsx)(i.li,{children:"Log only proof job metadata, never note/witness material."}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"8-acceptance-criteria",children:"8) Acceptance Criteria"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Withdraw with real proof confirms on Sepolia."}),"\n",(0,l.jsx)(i.li,{children:"Tampered recipient/fee/chainId fails verifier."}),"\n",(0,l.jsx)(i.li,{children:"Nullifier replay fails."}),"\n",(0,l.jsx)(i.li,{children:"Dev proof path disabled in production build."}),"\n",(0,l.jsx)(i.li,{children:"End-to-end tests pass for relayer + web + contracts using real proof fixture."}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:"Additional acceptance checks:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Adapter backend mode and verifier ABI alignment is verified in deployment checks."}),"\n",(0,l.jsx)(i.li,{children:"Poseidon tree/circuit root computation equality is tested against contract vectors."}),"\n",(0,l.jsx)(i.li,{children:"Proof encoding version mismatch is rejected by relayer with clear error."}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,l.jsx)(i,{...e,children:(0,l.jsx)(a,{...e})}):a(e)}},8453(e,i,n){n.d(i,{R:()=>c,x:()=>o});var r=n(6540);const l={},s=r.createContext(l);function c(e){const i=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:c(e.components),r.createElement(s.Provider,{value:i},e.children)}}}]);